<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一个复杂关系表达式过滤器的实现</title>
    <link href="/2022/07/12/java/%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/07/12/java/%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一个复杂关系表达式过滤器的实现"><a href="#一个复杂关系表达式过滤器的实现" class="headerlink" title="一个复杂关系表达式过滤器的实现"></a>一个复杂关系表达式过滤器的实现</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，有一个新需求，需要后台设置一个复杂的关系表达式，根据用户指定ID，解析该用用户是否满足该条件，后台设置类似于禅道的搜索条件</p><p><img src="http://image.wyxcl.xyz/typore/image-20220711141800946.png" alt="image-20220711141800946"></p><p>但是不同的是禅道有且仅有两个组，每个组最多三个条件</p><p>而我们这边组与关系可能是更复杂的，组中有组，每个条件都是有且或关系的。由于保密原因，原型就不发出来了。</p><p>​         看到这个需求，作为一个后端，第一时间想到的是类似QLEpress这类的表达式框架，只要构建一个表达式，通过解析表达式即可快速对目标用户进行筛选，但是可惜的是前端同学不干了，因为作为使用vue或react这类数据驱动的框架来说，将表达式转换为为上述的一个表单太难了 ，所以想了一下，决定自己定义一个数据结构，实现表达式解析。方便前端同学的处理。</p><h2 id="分析准备"><a href="#分析准备" class="headerlink" title="分析准备"></a>分析准备</h2><p>虽然是用类实现表达式，但是其本质上依旧还是个表达式，我们列举一个简单的表达式：设条件为a,b,c,d，我们随意构造一个表达式：</p><p><code> boolean result=a&gt;100 &amp;&amp; b=10 || (c != 3 &amp;&amp; d &lt; 50)</code></p><p>我们对表达式进行分析，可以发现表达式 都是共同属性有：</p><p><strong>过滤字段</strong>（a、b、c、d）,<strong>判断条件</strong>（大于、小于、不等于等等），<strong>对比值</strong>（a&gt;100 中的100）。</p><p>另外，还有<strong>关联关系</strong>（且、或）和<strong>计算优先级</strong>这几个属性组成。</p><p>于是我们对表达式进行简化：</p><p>令a&gt;100 &#x3D;&gt;A,b&#x3D;10 &#x3D;&gt;B,c!&#x3D;3&#x3D;&gt;C ,d&lt;50&#x3D;&gt;D,于是我们得到：</p><p><code> result=A &amp;&amp; B || (C &amp;&amp; D)</code></p><p>现在问题来了，如何处理优先级呢？</p><p>如上表达式，很明显，这是一个大学里学过的标准的中序表达式，于是，我们画一下它的树形图：</p><p><img src="http://image.wyxcl.xyz/typore/image-20220711150551736.png" alt="image-20220711150551736"></p><p>根据这个图，我们可以明显的看到，A且B 和C且D是同一级别，于是，我们按照这个理论设计一个层级的概念Deep，我们标注一下，然后再对节点的类型做一下区分，可得：</p><p><img src="http://image.wyxcl.xyz/typore/image-20220711161849589.png" alt="image-20220711161849589"></p><p>我们可以看到作为叶子节点（上图绿色部分），相对于其计算计算关系，遇到了一定是优先计算的，所以对于深度的优先级，我们仅需要考虑非叶子节点即可，即上图中的蓝色节点部分，于是我们得到了，计算<strong>优先级</strong>这个概念我们可以转换为表达式的<strong>深度</strong>。</p><p>我们再看上面这个图，Deep1 的关系是Deep2中 A且B 和 C且D两个表达式计算出的结果再进行与或关系的，我们设A 且B 为 G1， C且D为 G2，于是我们发现关系节点关联的类型有两种类型，一种是<strong>条件</strong>Condition ，一种是<strong>组</strong>Group</p><p><img src="http://image.wyxcl.xyz/typore/image-20220711163703243.png" alt="image-20220711163703243"></p><p>至此，这个类的雏形基本就确定了。这个类包含 <strong>关联关系</strong>（Relation）、<strong>判断字段</strong>（Field）、<strong>运算符</strong>（Operator）、运算值（Values）、<strong>类型</strong>（Type）、<strong>深度</strong>（Deep）</p><p>但是，有个问题，上面的分析中，我们在将表达式转换成树，现在我们试着将其还原，于是我们一眼可以得到其中一种表达式：</p><p><code> result=(A &amp;&amp; B)||(C &amp;&amp; D)</code> </p><p>很显然，和我们的原来的表达式并不一致，这是因为我们上述仅能记录表达式的计算顺序，而不能完全准确的表示这个表达式，这是因为在我们解析表达式的过程中，不仅是有深度、还有一个时序关系，即从左到右的顺序表示，而此时G1中的内容实际上在原表达式中的深度应该是1而不是2，然后我们引入序号的概念，将原来树变成有向的图即：</p><p><img src="http://image.wyxcl.xyz/typore/image-20220711170914684.png" alt="image-20220711170914684"></p><p>根据这个图，我们就还原出有且唯一的一个表达式了：<code> result= A &amp;&amp; B ||(C &amp;&amp; D)</code>。</p><p>好了，我们分析了半天，原理说完了，回到最初始的问题：<strong>前后端怎么实现</strong>？对着上图想象一下，貌似还是无法处理，因为这个结构还是太复杂了。对于前端，数据最好是方便遍历的，对于后端，数据最好是方便处理的，于是这时候我们需要将上面这个图转换成一个数组。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式:"></a>实现方式:</h2><p>上面说到了需要一个数组的结构，我们具体分析一下这个部分</p><p><img src="http://image.wyxcl.xyz/typore/image-20220711173732102.png" alt="image-20220711173732102"></p><p>我们发现作为叶子节点，可以始终优先计算，所以我们可以将其压缩，并将关系放置在其中一个表达式中形成 <code>^A -&gt; &amp;&amp;B</code>或 <code> A&amp;&amp; -&gt; B$</code> 的形式，这里我用正则的**开始(^)<strong>和</strong>结束($)**表示了一下开始 和 结束 的概念,这里为了与产品原型保持一致我们用第一种方式，即关系符号表示与前一个元素的关系，于是我们再分析一下：</p><p><img src="http://image.wyxcl.xyz/typore/image-20220711181008675.png" alt="image-20220711181008675"></p><p>再对序号进行改造：</p><p><img src="http://image.wyxcl.xyz/typore/image-20220711181924047.png" alt="image-20220711181924047"></p><p>于是我们得到最终的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExpressDto</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer seq;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 深度（运算优先级）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer deep;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关系运算符</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String relation;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String type;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 运算条件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String field;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 逻辑运算符</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String operator;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 运算值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String values;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 运算结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Boolean result;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>现在数据结构终于完成，既方便存储，又（相对）方便前台展示，现在构造一个稍微复杂的表达式</p><p><code>A &amp;&amp;(( B || C )|| (D &amp;&amp; E)) &amp;&amp; F</code></p><p>换成数组对象，开始用BEGIN标识，表达式类型用CONDITION表示，组用GROUP表示。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;seq&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;deep&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span>relation<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;BEGIN&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;CONDITION&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;field&quot;</span>=<span class="hljs-string">&quot;A&quot;</span>...<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;seq&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;deep&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span>relation<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;AND&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;GROUP&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span>...<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;seq&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;deep&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span>relation<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;BEGIN&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;GROUP&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span>...<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;seq&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;deep&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span>relation<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;BEGIN&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;CONDITION&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;B&quot;</span>...<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;seq&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">5</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;deep&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span>relation<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;OR&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;CONDITION&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;C&quot;</span>...<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;seq&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">6</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;deep&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span>relation<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;OR&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;GROUP&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span>...<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;seq&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">7</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;deep&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span>relation<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;BEGIN&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;CONDITION&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;D&quot;</span>...<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;seq&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">8</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;deep&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span>relation<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;AND&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;CONDITION&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;E&quot;</span>...<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;seq&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">9</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;deep&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span>relation<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;AND&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;CONDITION&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;F&quot;</span>...<span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>现在就剩最后一个问题：如何通过这个json对数据进行过滤了</p><p>由于数组对象的本质依旧是一个中缀表达式，所以其本质依旧是一个中缀表达式的解析，关于解析原理，这里不多介绍，简单的说就是通过数据栈和符号栈根据括号（在我们这里称为组）进行遍历，想了解更多，可以通过下面这篇文章复习一下</p><p><a href="https://zhuanlan.zhihu.com/p/44003911">https://zhuanlan.zhihu.com/p/44003911</a></p><p>于是我们定义三个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//关系 栈</span><br>Deque&lt;String&gt; relationStack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br><span class="hljs-comment">//结果栈</span><br>Deque&lt;Boolean&gt; resultStack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br><span class="hljs-comment">// 当前深度</span><br>Integer nowDeep=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>通过遍历数组，将关系与结果入栈，当发现需要优先计算的时候，从结果栈中取出两个值，从关系栈中取出关系运算符，计算后再次入栈，等待下一次计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (ExpressDto expressDto:list) &#123;<br>            <span class="hljs-keyword">if</span>(!StringUtils.equals(expressDto.getType(),<span class="hljs-string">&quot;GROUP&quot;</span>))&#123;<br>                <span class="hljs-comment">//TODO 进行具体单个表达式计算并获取结果</span><br>                resultStack.push(expressDto.getResult());<br>                <span class="hljs-comment">// 将关系放入栈中</span><br>                relationStack.push(expressDto.getRelation());<br>                <span class="hljs-keyword">if</span>(deep==<span class="hljs-number">0</span> &amp;&amp; resultStack.size()&gt;<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//由于已处理小于0的deep，当前deep理论上是&gt;=0的，0表示同等级，需要立即运算</span><br>                    relationOperator(relationStack, resultStack);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 将关系放入栈中</span><br>                relationStack.push(expressDto.getRelation());<br>            &#125;<br>        &#125; <br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">relationOperator</span><span class="hljs-params">(Deque&lt;String&gt; relationStack, Deque&lt;Boolean&gt; resultStack)</span> &#123;<br>        Boolean lastResult= resultStack.pop();<br>        Boolean firstResult= resultStack.pop();<br>        String relation=relationStack.pop();<br>        <span class="hljs-keyword">if</span>(StringUtils.equals(relation,<span class="hljs-string">&quot;AND&quot;</span>))&#123;<br>            resultStack.push(firstResult&amp;&amp; lastResult) ;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(StringUtils.equals(relation,<span class="hljs-string">&quot;OR&quot;</span>))&#123;<br>            resultStack.push( firstResult|| lastResult);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;表达式解析异常：关系表达式错误&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>再说一下注意的边界事项：</p><ol><li>首先我们同级中关联关系仅存在且、或两种，而这两种的计算优先级是一样的。故同一个Deep下，从左到右依次遍历计算即可。</li><li>当遇到GROUP的类型时，相当于遇到了”(“,我们可以发现它后面的元素Deep +1 直到Deep -1为止”)”结束，而括号中的元素需要优先计算，也就是说”()”所产生优先级通过Deep 和Type&#x3D;GROUP 共同控制</li><li>当Deep减少时，意味着遇到了”)”，此时结束的Group的数量等于Deep减少的数量，针对”)”结束，每遇到一个”)” 都需要对该级括号进行检查，是否同级别的元素是否已经计算完毕。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 处理层级遗留元素</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> relationStack</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> resultStack</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">computeBeforeEndGroup</span><span class="hljs-params">(Deque&lt;String&gt; relationStack, Deque&lt;Boolean&gt; resultStack)</span> &#123;<br>      <span class="hljs-type">boolean</span> isBeginSymbol=StringUtils.equals(relationStack.peek(),<span class="hljs-string">&quot;BEGIN&quot;</span>);<span class="hljs-comment">//防止group中仅有一个判断条件</span><br>      <span class="hljs-keyword">while</span>(!isBeginSymbol)&#123;<span class="hljs-comment">//上一个运算符非BEGIN，说明该group中还有运算需要优先处理，正常这里应该仅循环一次</span><br>          relationOperator(relationStack, resultStack);<br>          isBeginSymbol=StringUtils.equals(relationStack.peek(),<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span>(isBeginSymbol)&#123;<br>          relationStack.pop();<span class="hljs-comment">//该优先级处理完毕，将BEGIN运算符弹出</span><br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>当遍历结束发现最后一个元素Deep不等于1时，意味着有括号结束，这时，同样需要进行括号结束处理</li></ol><p>最后上完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 表达式解析器</span><br><span class="hljs-comment"> * 表达式规则：</span><br><span class="hljs-comment"> * 关系relation属性有：BEGIN、AND、OR 三种</span><br><span class="hljs-comment"> * 表达式类型 Type 属性有：GROUP、CONDITION 两种</span><br><span class="hljs-comment"> * 深度 deep 属性 根节点为 1，每增加一个括号（GROUP）deep+1，括号结束deep-1</span><br><span class="hljs-comment"> * 序号req：初始值为1，往后依次递增，用于防止表达式解析顺序错误</span><br><span class="hljs-comment"> * exp1：表达式：A &amp;&amp;(( B || C )|| (D &amp;&amp; E)) &amp;&amp; F</span><br><span class="hljs-comment"> * 分解对象：</span><br><span class="hljs-comment"> * [</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:1,&quot;deep&quot;:1,relation:&quot;BEGIN&quot;,&quot;type&quot;:&quot;CONDITION&quot;,&quot;field&quot;=&quot;A&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:2,&quot;deep&quot;:1,relation:&quot;AND&quot;,&quot;type&quot;:&quot;GROUP&quot;,&quot;field&quot;:&quot;&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:3,&quot;deep&quot;:2,relation:&quot;BEGIN&quot;,&quot;type&quot;:&quot;GROUP&quot;,&quot;field&quot;:&quot;&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:4,&quot;deep&quot;:3,relation:&quot;BEGIN&quot;,&quot;type&quot;:&quot;CONDITION&quot;,&quot;field&quot;:&quot;B&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:5,&quot;deep&quot;:3,relation:&quot;OR&quot;,&quot;type&quot;:&quot;CONDITION&quot;,&quot;field&quot;:&quot;C&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:6,&quot;deep&quot;:2,relation:&quot;OR&quot;,&quot;type&quot;:&quot;GROUP&quot;,&quot;field&quot;:&quot;&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:7,&quot;deep&quot;:3,relation:&quot;BEGIN&quot;,&quot;type&quot;:&quot;CONDITION&quot;,&quot;field&quot;:&quot;D&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:8,&quot;deep&quot;:3,relation:&quot;AND&quot;,&quot;type&quot;:&quot;CONDITION&quot;,&quot;field&quot;:&quot;E&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:9,&quot;deep&quot;:1,relation:&quot;AND&quot;,&quot;type&quot;:&quot;CONDITION&quot;,&quot;field&quot;:&quot;F&quot;...&#125;</span><br><span class="hljs-comment"> * ]</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * exp2:(A || B &amp;&amp; C)||(D &amp;&amp; E &amp;&amp; F)</span><br><span class="hljs-comment"> * [</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:1,&quot;deep&quot;:1,relation:&quot;BEGIN&quot;,&quot;type&quot;:&quot;GROUP&quot;,&quot;field&quot;:&quot;&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:2,&quot;deep&quot;:2,relation:&quot;BEGIN&quot;,&quot;type&quot;:&quot;CONDITION&quot;,&quot;field&quot;:&quot;A&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:3,&quot;deep&quot;:2,relation:&quot;OR&quot;,&quot;type&quot;:&quot;CONDITION&quot;,&quot;field&quot;:&quot;B&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:4,&quot;deep&quot;:2,relation:&quot;AND&quot;,&quot;type&quot;:&quot;CONDITION&quot;,&quot;field&quot;:&quot;C&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:5,&quot;deep&quot;:1,relation:&quot;OR&quot;,&quot;type&quot;:&quot;GROUP&quot;,&quot;field&quot;:&quot;&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:6,&quot;deep&quot;:2,relation:&quot;BEGIN&quot;,&quot;type&quot;:&quot;CONDITION&quot;,&quot;field&quot;:&quot;D&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:7,&quot;deep&quot;:2,relation:&quot;AND&quot;,&quot;type&quot;:&quot;CONDITION&quot;,&quot;field&quot;:&quot;E&quot;...&#125;,</span><br><span class="hljs-comment"> * &#123;&quot;seq&quot;:8,&quot;deep&quot;:2,relation:&quot;AND&quot;,&quot;type&quot;:&quot;CONDITION&quot;,&quot;field&quot;:&quot;F&quot;...&#125;</span><br><span class="hljs-comment"> * ]</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">expressProcessor</span><span class="hljs-params">(List&lt;ExpressDto&gt;list)</span>&#123;<br>    <span class="hljs-comment">//关系 栈</span><br>    Deque&lt;String&gt; relationStack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>    <span class="hljs-comment">//结果栈</span><br>    Deque&lt;Boolean&gt; resultStack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>    <span class="hljs-comment">// 当前深度</span><br>    Integer nowDeep=<span class="hljs-number">1</span>;<br>    Integer seq=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (ExpressDto expressDto:list) &#123;<br>        <span class="hljs-comment">// 顺序检测，防止顺序错误</span><br>        <span class="hljs-type">int</span> checkReq=expressDto.getSeq()-seq;<br>        <span class="hljs-keyword">if</span>(checkReq!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;表达式异常：解析顺序异常&quot;</span>);<br>        &#125;<br>        seq=expressDto.getSeq();<br>        <span class="hljs-comment">//计算深度（计算优先级），判断当前逻辑是否需要处理括号</span><br>        <span class="hljs-type">int</span> deep=expressDto.getDeep()-nowDeep;<br>        <span class="hljs-comment">// 赋予当前深度</span><br>        nowDeep=expressDto.getDeep();<br>        <span class="hljs-comment">//deep 减小，说明有括号结束，需要处理括号到对应的层级，deep减少数量等于组（&quot;）&quot;）结束的数量</span><br>        <span class="hljs-keyword">while</span>(deep++ &lt; <span class="hljs-number">0</span>)&#123;<br>            computeBeforeEndGroup(relationStack, resultStack);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!StringUtils.equals(expressDto.getType(),<span class="hljs-string">&quot;GROUP&quot;</span>))&#123;<br>            <span class="hljs-comment">//TODO 进行具体单个表达式计算并获取结果</span><br>            resultStack.push(expressDto.getResult());<br>            <span class="hljs-comment">// 将关系放入栈中</span><br>            relationStack.push(expressDto.getRelation());<br>            <span class="hljs-keyword">if</span>(deep==<span class="hljs-number">0</span> &amp;&amp; resultStack.size()&gt;<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//由于已处理小于0的deep，当前deep理论上是&gt;=0的，0表示同等级，需要立即运算</span><br>                relationOperator(relationStack, resultStack);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 将关系放入栈中</span><br>            relationStack.push(expressDto.getRelation());<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//遍历完毕，处理栈中未进行运算的节点</span><br>    <span class="hljs-keyword">while</span>(nowDeep-- &gt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 这里使用 nowdeep&gt;0 的原因是最后deep=1的关系表达式也需要进行处理</span><br>        computeBeforeEndGroup(relationStack, resultStack);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(resultStack.size()!=<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;表达式解析异常:解析结果数量异常解析数量:&quot;</span>+resultStack.size());<br>    &#125;<br>    <span class="hljs-keyword">return</span> resultStack.pop();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理层级遗留元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> relationStack</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resultStack</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">computeBeforeEndGroup</span><span class="hljs-params">(Deque&lt;String&gt; relationStack, Deque&lt;Boolean&gt; resultStack)</span> &#123;<br>    <span class="hljs-type">boolean</span> isBeginSymbol=StringUtils.equals(relationStack.peek(),<span class="hljs-string">&quot;BEGIN&quot;</span>);<span class="hljs-comment">//防止group中仅有一个判断条件</span><br>    <span class="hljs-keyword">while</span>(!isBeginSymbol)&#123;<span class="hljs-comment">//上一个运算符非BEGIN，说明该group中还有运算需要优先处理，正常这里应该仅循环一次</span><br>        relationOperator(relationStack, resultStack);<br>        isBeginSymbol=StringUtils.equals(relationStack.peek(),<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(isBeginSymbol)&#123;<br>        relationStack.pop();<span class="hljs-comment">//该优先级处理完毕，将BEGIN运算符弹出</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 关系运算处理</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> relationStack</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resultStack</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">relationOperator</span><span class="hljs-params">(Deque&lt;String&gt; relationStack, Deque&lt;Boolean&gt; resultStack)</span> &#123;<br>    Boolean lastResult= resultStack.pop();<br>    Boolean firstResult= resultStack.pop();<br>    String relation=relationStack.pop();<br>    <span class="hljs-keyword">if</span>(StringUtils.equals(relation,<span class="hljs-string">&quot;AND&quot;</span>))&#123;<br>        resultStack.push(firstResult&amp;&amp; lastResult) ;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(StringUtils.equals(relation,<span class="hljs-string">&quot;OR&quot;</span>))&#123;<br>        resultStack.push( firstResult|| lastResult);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;表达式解析异常：关系表达式错误&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单写了几个测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 表达式：A</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expTest0</span><span class="hljs-params">()</span>&#123;<br>        ExpressDto E1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">1</span>).setResult(<span class="hljs-literal">false</span>).setSeq(<span class="hljs-number">1</span>).setType(<span class="hljs-string">&quot;CONDITION&quot;</span>).setField(<span class="hljs-string">&quot;A&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        List&lt;ExpressDto&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        list.add(E1);<br>        <span class="hljs-type">boolean</span> re=expressProcessor(list);<br>        Assertions.assertFalse(re);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 表达式：(A &amp;&amp; B)||(C || D)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expTest1</span><span class="hljs-params">()</span>&#123;<br>        ExpressDto E1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">1</span>).setSeq(<span class="hljs-number">1</span>).setType(<span class="hljs-string">&quot;GROUP&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        ExpressDto E2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">2</span>).setResult(<span class="hljs-literal">true</span>).setSeq(<span class="hljs-number">2</span>).setType(<span class="hljs-string">&quot;Condition&quot;</span>).setField(<span class="hljs-string">&quot;A&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        ExpressDto E3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">2</span>).setResult(<span class="hljs-literal">false</span>).setSeq(<span class="hljs-number">3</span>).setType(<span class="hljs-string">&quot;Condition&quot;</span>).setField(<span class="hljs-string">&quot;B&quot;</span>).setRelation(<span class="hljs-string">&quot;AND&quot;</span>);<br>        ExpressDto E4=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">1</span>).setSeq(<span class="hljs-number">4</span>).setType(<span class="hljs-string">&quot;GROUP&quot;</span>).setRelation(<span class="hljs-string">&quot;OR&quot;</span>);<br>        ExpressDto E5=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">2</span>).setResult(<span class="hljs-literal">true</span>).setSeq(<span class="hljs-number">5</span>).setType(<span class="hljs-string">&quot;Condition&quot;</span>).setField(<span class="hljs-string">&quot;C&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        ExpressDto E6=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">2</span>).setResult(<span class="hljs-literal">false</span>).setSeq(<span class="hljs-number">6</span>).setType(<span class="hljs-string">&quot;Condition&quot;</span>).setField(<span class="hljs-string">&quot;D&quot;</span>).setRelation(<span class="hljs-string">&quot;OR&quot;</span>);<br><br>        List&lt;ExpressDto&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        list.add(E1);<br>        list.add(E2);<br>        list.add(E3);<br>        list.add(E4);<br>        list.add(E5);<br>        list.add(E6);<br>        <span class="hljs-type">boolean</span> re=expressProcessor(list);<br>        Assertions.assertTrue(re);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 表达式：A &amp;&amp; (B || C &amp;&amp; D)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expTest2</span><span class="hljs-params">()</span>&#123;<br>        ExpressDto E1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">1</span>).setResult(<span class="hljs-literal">true</span>).setSeq(<span class="hljs-number">1</span>).setType(<span class="hljs-string">&quot;Condition&quot;</span>).setField(<span class="hljs-string">&quot;A&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        ExpressDto E2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">1</span>).setSeq(<span class="hljs-number">2</span>).setType(<span class="hljs-string">&quot;GROUP&quot;</span>).setRelation(<span class="hljs-string">&quot;AND&quot;</span>);<br>        ExpressDto E3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">2</span>).setResult(<span class="hljs-literal">false</span>).setSeq(<span class="hljs-number">3</span>).setType(<span class="hljs-string">&quot;Condition&quot;</span>).setField(<span class="hljs-string">&quot;B&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        ExpressDto E4=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">2</span>).setResult(<span class="hljs-literal">false</span>).setSeq(<span class="hljs-number">4</span>).setType(<span class="hljs-string">&quot;Condition&quot;</span>).setField(<span class="hljs-string">&quot;C&quot;</span>).setRelation(<span class="hljs-string">&quot;OR&quot;</span>);<br>        ExpressDto E5=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">2</span>).setResult(<span class="hljs-literal">true</span>).setSeq(<span class="hljs-number">5</span>).setType(<span class="hljs-string">&quot;Condition&quot;</span>).setField(<span class="hljs-string">&quot;D&quot;</span>).setRelation(<span class="hljs-string">&quot;AND&quot;</span>);<br>        List&lt;ExpressDto&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        list.add(E1);<br>        list.add(E2);<br>        list.add(E3);<br>        list.add(E4);<br>        list.add(E5);<br>        <span class="hljs-type">boolean</span> re=expressProcessor(list);<br>        Assertions.assertFalse(re);<br>        E4.setResult(<span class="hljs-literal">true</span>);<br>        list.set(<span class="hljs-number">3</span>,E4);<br>        re=expressProcessor(list);<br>        Assertions.assertTrue(re);<br>        E1.setResult(<span class="hljs-literal">false</span>);<br>        list.set(<span class="hljs-number">0</span>,E1);<br>        re=expressProcessor(list);<br>        Assertions.assertFalse(re);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expTest3</span><span class="hljs-params">()</span>&#123;<br>        ExpressDto E1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">1</span>).setResult(<span class="hljs-literal">true</span>).setSeq(<span class="hljs-number">1</span>).setType(<span class="hljs-string">&quot;Condition&quot;</span>).setField(<span class="hljs-string">&quot;A&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        ExpressDto E2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">1</span>).setSeq(<span class="hljs-number">2</span>).setType(<span class="hljs-string">&quot;GROUP&quot;</span>).setRelation(<span class="hljs-string">&quot;OR&quot;</span>);<br>        ExpressDto E3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">2</span>).setResult(<span class="hljs-literal">true</span>).setSeq(<span class="hljs-number">3</span>).setType(<span class="hljs-string">&quot;Condition&quot;</span>).setField(<span class="hljs-string">&quot;B&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        ExpressDto E4=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">2</span>).setSeq(<span class="hljs-number">4</span>).setType(<span class="hljs-string">&quot;GROUP&quot;</span>).setRelation(<span class="hljs-string">&quot;AND&quot;</span>);<br>        ExpressDto E5=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">3</span>).setResult(<span class="hljs-literal">true</span>).setSeq(<span class="hljs-number">5</span>).setType(<span class="hljs-string">&quot;Condition&quot;</span>).setField(<span class="hljs-string">&quot;C&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        ExpressDto E6=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">3</span>).setResult(<span class="hljs-literal">false</span>).setSeq(<span class="hljs-number">6</span>).setType(<span class="hljs-string">&quot;Condition&quot;</span>).setField(<span class="hljs-string">&quot;D&quot;</span>).setRelation(<span class="hljs-string">&quot;OR&quot;</span>);<br><br>        List&lt;ExpressDto&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        list.add(E1);<br>        list.add(E2);<br>        list.add(E3);<br>        list.add(E4);<br>        list.add(E5);<br>        list.add(E6);<br>        <span class="hljs-type">boolean</span> re=expressProcessor(list);<br>        Assertions.assertTrue(re);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 表达式：A &amp;&amp;(( B || C )|| (D &amp;&amp; E))</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expTest4</span><span class="hljs-params">()</span>&#123;<br>        ExpressDto E1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">1</span>).setSeq(<span class="hljs-number">1</span>).setType(<span class="hljs-string">&quot;CONDITION&quot;</span>).setResult(<span class="hljs-literal">true</span>).setField(<span class="hljs-string">&quot;A&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        ExpressDto E2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">1</span>).setSeq(<span class="hljs-number">2</span>).setType(<span class="hljs-string">&quot;GROUP&quot;</span>).setRelation(<span class="hljs-string">&quot;AND&quot;</span>);<br>        ExpressDto E3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">2</span>).setSeq(<span class="hljs-number">3</span>).setType(<span class="hljs-string">&quot;GROUP&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        ExpressDto E4=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">3</span>).setSeq(<span class="hljs-number">4</span>).setType(<span class="hljs-string">&quot;CONDITION&quot;</span>).setResult(<span class="hljs-literal">true</span>).setField(<span class="hljs-string">&quot;B&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        ExpressDto E5=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">3</span>).setSeq(<span class="hljs-number">5</span>).setType(<span class="hljs-string">&quot;CONDITION&quot;</span>).setResult(<span class="hljs-literal">true</span>).setField(<span class="hljs-string">&quot;C&quot;</span>).setRelation(<span class="hljs-string">&quot;OR&quot;</span>);<br>        ExpressDto E6=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">2</span>).setSeq(<span class="hljs-number">6</span>).setType(<span class="hljs-string">&quot;GROUP&quot;</span>).setRelation(<span class="hljs-string">&quot;OR&quot;</span>);<br>        ExpressDto E7=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">3</span>).setSeq(<span class="hljs-number">7</span>).setType(<span class="hljs-string">&quot;CONDITION&quot;</span>).setResult(<span class="hljs-literal">false</span>).setField(<span class="hljs-string">&quot;D&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        ExpressDto E8=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">3</span>).setSeq(<span class="hljs-number">8</span>).setType(<span class="hljs-string">&quot;CONDITION&quot;</span>).setResult(<span class="hljs-literal">false</span>).setField(<span class="hljs-string">&quot;E&quot;</span>).setRelation(<span class="hljs-string">&quot;AND&quot;</span>);<br>        List&lt;ExpressDto&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        list.add(E1);<br>        list.add(E2);<br>        list.add(E3);<br>        list.add(E4);<br>        list.add(E5);<br>        list.add(E6);<br>        list.add(E7);<br>        list.add(E8);<br>        <span class="hljs-type">boolean</span> re=expressProcessor(list);<br>        Assertions.assertTrue(re);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 表达式：(A)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expTest5</span><span class="hljs-params">()</span>&#123;<br>        ExpressDto E1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">1</span>).setSeq(<span class="hljs-number">1</span>).setType(<span class="hljs-string">&quot;GROUP&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        ExpressDto E2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressDto</span>().setDeep(<span class="hljs-number">2</span>).setResult(<span class="hljs-literal">true</span>).setSeq(<span class="hljs-number">2</span>).setType(<span class="hljs-string">&quot;Condition&quot;</span>).setField(<span class="hljs-string">&quot;A&quot;</span>).setRelation(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        List&lt;ExpressDto&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        list.add(E1);<br>        list.add(E2);<br>        <span class="hljs-type">boolean</span> re=expressProcessor(list);<br>        Assertions.assertTrue(re);<br>        E2.setResult(<span class="hljs-literal">false</span>);<br>        list.set(<span class="hljs-number">1</span>,E2);<br>        Assertions.assertFalse(expressProcessor(list));<br>    &#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><p><img src="http://image.wyxcl.xyz/typore/image-20220712092039886.png" alt="image-20220712092039886"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漫谈java网站开发中的各种锁</title>
    <link href="/2022/06/19/java/%E5%9F%BA%E7%A1%80/%E6%BC%AB%E8%B0%88java%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/"/>
    <url>/2022/06/19/java/%E5%9F%BA%E7%A1%80/%E6%BC%AB%E8%B0%88java%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="漫谈java网站开发中的各种锁"><a href="#漫谈java网站开发中的各种锁" class="headerlink" title="漫谈java网站开发中的各种锁"></a>漫谈java网站开发中的各种锁</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​        从学习  java 开始，我们就学习或听说各种各样的锁、比如使用java多线程时的线程锁 <strong>synchronized</strong> 以及 <strong>concurrent</strong> （也称 JUC）包下的<strong>Lock</strong>锁。在接下来涉及数据库及事务的时候又涉及了数据库的锁。再后来，在高并发、多节点应用涉及一致性的问题中，又涉及了分布式锁，那么这些锁有什么区别于关联呢？</p><h2 id="锁的各种分类及基础思想"><a href="#锁的各种分类及基础思想" class="headerlink" title="锁的各种分类及基础思想"></a>锁的各种分类及基础思想</h2><p>锁的分类有很多种，根据不同的思想，有不同的分类比如：</p><p>在分布式锁及线程锁中：</p><ul><li>根据资源的在加锁过程中其他资源的可读性分为：<strong>乐观锁</strong> 和 <strong>悲观锁</strong></li><li>根据多线程或多进程中是否根据先进先出的原则进行持锁分为<strong>公平锁</strong> 和 <strong>非公平锁</strong></li><li>在同一资源获取到锁后是否可以多次重复加锁分为 <strong>可重入锁</strong> 和 <strong>非可重入锁</strong></li><li>在锁的重量级或流程细节中分为：<strong>无锁</strong>、<strong>偏向锁</strong>、<strong>轻量级锁</strong>、<strong>重量级锁</strong></li><li>根据多资源是否可以获取到加锁资源分为 <strong>共享锁</strong> 与  <strong>排它锁</strong></li></ul><p>在设计数据库事务中，除了上述的乐观锁、悲观锁等概念外，还有：</p><ul><li>锁粒度划分的<strong>行锁</strong>、<strong>表锁</strong>、<strong>库锁</strong>(记录锁、间隙锁、临键锁)</li><li>基于锁的状态分类：<strong>意向共享锁</strong>、<strong>意向排它锁</strong></li></ul><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p>​        这两个名词其实是一种思想，无论是在线程锁还是数据库锁，原理上都是一致的，乐观锁本质是CAS思想 ,什么是CAS？</p><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>再举个简单直接的例子：比如在数据库乐观锁中，我们常见的方案是会设置一个   <code>version</code> 的字段，在每次更新时，约定version必须加1，,再通过判断version的版本号判断数据是否进行过更改。大概sql为：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> table_name <span class="hljs-keyword">set</span> xx <span class="hljs-operator">=</span> xx ，version <span class="hljs-operator">=</span> version <span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">where</span> version<span class="hljs-operator">=</span>#&#123;version&#125; <br></code></pre></td></tr></table></figure><p>当然从上述思想中，我们也不难看出乐观锁存在的问题：</p><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>CAS操作如果长时间不成功，会导致其一直自旋，给CPU或存储带来非常大的开销。</p><h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>​        这两个概念其实讲述的是锁争抢时处理的一种思路，其实就是在获取锁的过程中增加一个队列，根据队列的入队顺序获取锁资源。拿比较常用的java中的可重入锁举例，公平锁与非公平锁在实现的过程中唯一的区别是在争抢锁（tryAcquire）的判断的时候公平锁（FairLock）增加了一个 <code>hasQueuedPredecessors（）</code> 的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>          <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>          <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>          <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//hasQueuedPredecessors这个方法就是最大区别所在</span><br>              <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                  compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                  setExclusiveOwnerThread(current);<br>                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>              &#125;<br>          &#125;<br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>              <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>              <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>              setState(nextc);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><p><img src="https://image.wyxcl.xyz/bd0036bb.png" alt="img"></p><h3 id="可重入锁与非可重入锁"><a href="#可重入锁与非可重入锁" class="headerlink" title="可重入锁与非可重入锁"></a>可重入锁与非可重入锁</h3><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p><p>简单举例来说就是 我们都知道java的<strong>synchronized</strong> 是相对类加锁的，那么如果同一个类有多个带有 synchronized 的方法并相互调用时，通过可重入机制避免了死锁的现象，个人理解为其本质就是软件设计中 PV 操作的思想。</p><h3 id="无锁、偏向锁、轻量级锁、重量级锁"><a href="#无锁、偏向锁、轻量级锁、重量级锁" class="headerlink" title="无锁、偏向锁、轻量级锁、重量级锁"></a>无锁、偏向锁、轻量级锁、重量级锁</h3><p>这四个其实是锁的从轻到重的四种状态，这个在下文讲synchronized锁升级的时 再重点讲述，在这里只是大概讲述一下大概的名词解释，</p><p>无锁： 就是在资源不发生争抢时，不对共享资源进行加锁。即共享资源查询、修改频率非常低，不会加锁</p><p>偏向锁：当某个线程频繁调用这个共享资源而其他线程相对较少的时候，记录上一次持有该资源的线程做标记，优先使该线程或取到锁资源</p><p>轻量级锁： 即自旋锁，通过CAS刷新获取锁资源</p><p>重量级锁：即对资源进行加锁，持锁才能访问</p><h3 id="共享锁与排它锁"><a href="#共享锁与排它锁" class="headerlink" title="共享锁与排它锁"></a>共享锁与排它锁</h3><p>这个概念主要体现在读写锁中，比如读锁即是一个典型的共享锁，可以同时被多个线程持有，写锁为排它锁，该锁只能同一个线程进行持有，这里注意的是共享锁不等于无锁，比如读写锁中，资源是在读锁与写锁之间进行切换的，即读锁的时候，多线程可以进入读取，写锁时，仅一个线程可以写入，其他线程既不可以读也不可以写</p><h2 id="JAVA中的线程锁"><a href="#JAVA中的线程锁" class="headerlink" title="JAVA中的线程锁"></a>JAVA中的线程锁</h2><p>前面我们提到了java中的线程锁 synchronized  以及  JUC 包下的对LOCK接口的实现，现在分别讲一下这两种锁</p><h3 id="synchronized-锁"><a href="#synchronized-锁" class="headerlink" title="synchronized  锁"></a>synchronized  锁</h3><p>synchronized  锁大概率是我们接触java后遇到的第一种锁，使用起来简单，方便，可以直接加在方法上，也可以加在代码块上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span><br>&#123;<br>   <span class="hljs-comment">// todo</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span><br>&#123;<br>   <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>      <span class="hljs-comment">// todo</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而持锁对象，可以是类的实例对象，也可以是静态类的类对象</p><p>说到持锁对象，实际上就是锁的一个载体，我们都知道一个对象是分为三个部分：</p><p>对象头、对象实例、填充数据</p><p>对象头中包含：<strong>Klass Point</strong> (类型指针) 和 <strong>Mark Word</strong> (标记字段)</p><p><strong>Klass Point</strong> 是<strong>对象指向它的类元数据的指针</strong>，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>Mark Word</strong> 这一部分<strong>用于储存对象自身的运行时的数据</strong>，如哈希码、GC 分代年龄、锁状态标志、锁指针等。这部分数据在 32 bit 和 64 bit 的虚拟机中大小分别为 32 bit 和 64 bit，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构，以便在极小的空间中存储尽量多的信息，它会根据对象的状态复用自己的存储空间(跟 ConcurrentHashMap 里的标志位类似)，详细情况如下图：</p><p><img src="http://image.wyxcl.xyz/typore/3b292df5e0fe99255d893a02a839e8d88cb17170.png" alt="img"></p><h4 id="synchronized的锁升级过程"><a href="#synchronized的锁升级过程" class="headerlink" title="synchronized的锁升级过程"></a>synchronized的锁升级过程</h4><p>java1.6之前，synchronized是一个重量级的锁，但是，在1.6开始后synchronized变成了一个可升级的锁</p><p>简单的来说，在无竞争的时候sync使用偏向锁，如果偏向锁失败了（一个对象被不同的线程加锁了），就会升级为轻量级锁，如果有线程的竞争，就升级为重量级锁。</p><p>详细的说，偏向锁的标记被记录在了markwork里面，标志位为100，偏向锁的线程id也被记录在了对象头中，线程访问同步代码块的时候，就会用cas检查对象头记录的线程id是不是当前线程，如果不是，就cas把替换线程id，如果成功就获得偏向锁。如果是当前线程，也获得偏向锁。如果替换失败，就当偏向锁线程达到安全点的时候，升级为轻量级锁。偏向锁的意思就是偏向第一个访问的线程。</p><p>轻量级锁的线程信息存储在当前线程的栈帧中，并将对象头中的markword复制到锁记录中，然后线程尝试使用cas将对象头中的markword替换为指向锁记录的指针，如果成功，当前线程获得锁，如果失败，表示有其他线程竞争，自旋一定的次数后就会升级为重量级锁。重量级锁使除了拥有锁的线程以外的线程都阻塞。</p><h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><p>java中两外一个线程锁就是 concurrent 包下的Lock接口，在java的concurrent中对该接口常用的实现有ReentrantLock、ReentrantReadWriteLock两种，这两个锁最大的区别是后者是读写锁，分为ReadLock 和 WriteLock 两个，这两个锁互斥，且ReadLock是一个共享锁</p><hr><p>未完（待续）</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UML图概述</title>
    <link href="/2022/05/22/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/UML/UML%E7%BB%BC%E8%BF%B0/"/>
    <url>/2022/05/22/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/UML/UML%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    前一段时间开始，因为工作性质变化的原因，除了日常的coding外，还承担了一些项目的技术预案、立项、等文档的编写等相关工作，需要画大量的技术架构相关的一些图。涉及到了比较多的UML图。 借此机会，我也重新复习一下各类UML吧。</p><h2 id="什么是UML"><a href="#什么是UML" class="headerlink" title="什么是UML"></a>什么是UML</h2><p>UML即<strong>Unified Model Language</strong>，是一种建模语言，它以<strong>图形的方式</strong>来描述软件的概念,也是标准建模语言。在软件开发中，当系统规模比较复杂时，需要用图形抽象地来表达复杂的概念，让整个软件设计更具有可读性，可理解性，以便尽早发现软件设计时存在的潜在问题，从而降低开发风险。同时，也极大地方便了业务人员与开发人员之间的交流。</p><h2 id="UML分类"><a href="#UML分类" class="headerlink" title="UML分类"></a>UML分类</h2><p>UML 是一个总称，共包含共10 种图：</p><p>其中包含<code>静态图</code>也称<code>结构视图</code> 6种：<code>用例图</code> 、 <code>类图</code>、<code>包图</code>、<code>对象图</code>、<code>部署图</code></p><p><code>动态图</code>也称为<code>行为视图</code>4种： <code>顺序</code>、<code>协作</code>、<code>状态</code>、<code>活动图</code></p><p><img src="https://image.wyxcl.xyz/023b5bb5c9ea15ced94bd52936dfd3fb3b87b255.png" alt="img"></p><p>其中常用的有： </p><p><strong>常用的静态图</strong>：用例图、类图、包图、对象图、部署图</p><p><strong>常用的动态图</strong>：顺序图，协作图（也称为通信图），状态机图，活动图</p><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p>用例图是参与者从系统外部能观察到的系统功能的模型图。用例是系统中的一个功能单元，可以描述为参与者与系统之间的一次交互。用例图即是描述出系统的参与者以及参与者可以执行的系统用例。</p><p><img src="https://image.wyxcl.xyz/20210105150434821.png" alt="最简单的用例图"></p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>用于描述系统中所包含的类以及它们之间的相互关系。</p><p>类图的两个重要元素：类，以及类之间的关系。</p><p>类的关系<strong>（6种）</strong>：<strong>依赖关系、继承&#x2F;泛化关系、实线关系、关联关系、聚合关系、组合关系</strong></p><p><img src="https://image.wyxcl.xyz/uml_class_struct.jpg" alt="_images/uml_class_struct.jpg"></p><h3 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h3><h3 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h3><p>包图通常用于描述系统的逻辑架构——层、子系统、包等。层可以建模为UML包。UML包用一大一小两个矩形组合而成。如果内部显示了其成员，则包名称标在上面的小矩形内，否则可以标在包内。</p><p><img src="https://image.wyxcl.xyz/241f95cad1c8a7866f5fa7c5fa36563571cf5048.jpeg" alt="img"></p><p>包拥有的元素<strong>：类、接口、组件、节点、协作、用例、图以及其他包。</strong>包的可见性用来控制包外界的元素对包内元素的可访问权限。这种可见性它分为3种，即公有访问、保护访问和私有访问。</p><p>包之间可以有两种关系：<strong>依赖、泛化</strong>。</p><h3 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h3><p>UML 组件图（Component Diagram）又称为构件图，他描述的是在软件系统中遵从并实现一组接口的物理的、可替换的软件模块。</p><p>组件图 &#x3D; 构件（Component）+接口（Interface）+关系（Relationship）+端口（Port）+连接器（Connector）</p><p>UML 组件图给提供了将要建立的系统的高层次的架构视图，这将帮助开发者开始建立实现的路标，并决定关于任务分配及（或）增进需求技能。</p><p><img src="https://image.wyxcl.xyz/1130413-20190208210743838-151551384.png" alt="img"></p><h3 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h3><p>部署图是用来显示系统中软件和硬件的物理架构。使用部署图不仅可以显示运行时系统的结构，还能够传达构成应用程序的硬件和软件元素的配置和部署方式。</p><p>部署图的组成元素：<strong>结点、构件</strong>（因此部署图也经常和构件图一起使用）、<strong>接口、连接</strong>。</p><p><img src="https://image.wyxcl.xyz/1503392775828972.jpg" alt="1049196244-0"></p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>UML 状态图是图表本身的名称，主要用于描述对象具有的各种状态、状态之间的转换过程以及触发状态转换的各种事件和条件。</p><p>UML 状态图描述了一个状态机，可以被定义为一台机器，它定义了一个对象，这些状态控制外部或内部事件的不同状态。</p><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><p>活动图是一种用于描述系统行为的模型视图，它可以用来描述系统的工作流程和并发行为，用于展现参与系统某一行为的类进行的各种活动的顺序关系。</p><p>活动图类似于流程图，可以描述过程逻辑、业务流程和工作流，但活动图支持并发行为。</p><p><img src="https://image.wyxcl.xyz/3b292df5e0fe992583d545a39697c1d78cb1712b.jpeg" alt="img"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>序列图（Sequence Diagram），又称顺序图或时序图，它是描述对象行为的一种交互视图。</p><p><img src="https://image.wyxcl.xyz/D0wkkHSbtC6VUSHX4WsjP5ssg5mdnEmXO8NGVGF34dxS9N1WCcq6wvquR4K_Hcut" alt="img"></p><h3 id="协作图"><a href="#协作图" class="headerlink" title="协作图"></a>协作图</h3><p>通信图描述的是对象和对象之间的调用关系，体现的是一种组织关系。</p><p>通信图组成元素：<strong>对象、链接、消息</strong>。</p><p>通信图和时序图有点类似。但时序图着重于时间顺序，而通信图则关注的是对象之间的组织关系，通信图中的时间顺序可以从消息序号中获得。在语义上这两个图是等价的可以互相转换而不会丢失信息。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计基础</category>
      
      <category>UML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件设计基础</tag>
      
      <tag>UML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot手写一个简单的登录验证方案</title>
    <link href="/2022/05/20/java/springboot/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%99%BB%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/05/20/java/springboot/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%99%BB%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​       最近接了一个小项目，需要分为前后台两个部分，前台已小程序的方式嵌入，后台有一个简单的管理界面，由于对权限要求简单，不需要复杂的权限逻辑，所以不想引入类似spring security 或者 Shiro 这样重量级的框架。于是决定手写一个简单的登录。</p><h2 id="基础框架的的选择"><a href="#基础框架的的选择" class="headerlink" title="基础框架的的选择"></a>基础框架的的选择</h2><p>​        因为项目功能非常简单，且后期可扩展性不强，前后端分离，基础框架就简单的使用了一个 springboot、提供最基础的resful接口，没有使用微服务架构。使用springCloud的话也类似</p><h2 id="登录的核心问题"><a href="#登录的核心问题" class="headerlink" title="登录的核心问题"></a>登录的核心问题</h2><ul><li>接口的拦截与白名单控制</li><li>登录信息在不同机器上的共享方式</li><li>怎么在程序的各个位置获取到登录用户信息、鉴权</li><li>IP控制及限制单用户登录的问题</li></ul><h2 id="登录信息共享方式"><a href="#登录信息共享方式" class="headerlink" title="登录信息共享方式"></a>登录信息共享方式</h2><ul><li>session+cookie共享方式</li><li>生成token</li><li>JWT 共享</li></ul><p>session+cookie的共享方案是传统的方案机制、需要引入springsession、spring-security等依赖，这里不做了，有兴趣的可以参考：<a href="https://juejin.cn/post/6844903859358285831">https://juejin.cn/post/6844903859358285831</a></p><p>下面 token及JWT类似，都是根据用户信息生成一个字符串传个前端，前端在请求的时候需要携带该token，不同点是JWT本身携带用户信息及过期时间，且JWT本身是一个无状态的，所以相对于token来说优点是无需保存用户信息，而token方式需要保存在服务端，通常在redis中，JWT只需要验签及获取JWT中的用户信息即可。</p><p><img src="http://image.wyxcl.xyz/typore/cc420cac591448b1b6a279efa5c5d52e-16530202993042.png" alt="JWT交互流程"></p><p>缺点是，JWT存在过期时间，续期需要更换整个token，这时需要前端配合更新。另外，由于JWT的无状态性，导致了登出后token在有效期内依旧是有效的，这种方式存在一定问题，所以很多文章中上有通过redis等方式给JWT赋予了状态，个人认为，这其实是违背了JWT的原意。所以我认为JWT更适合于一次性验证的业务流程，而不是用作登录会话的管理，因为用户登录行为本身就是有状态的，与JWT的无状态冲突。</p><h2 id="登录的接口拦截方案"><a href="#登录的接口拦截方案" class="headerlink" title="登录的接口拦截方案"></a>登录的接口拦截方案</h2><p>在springboot上，可选择的拦截方案有三种：</p><ul><li>通过WebFilter进行拦截</li><li>通过Intercepter进行拦截</li><li>通过aop进行拦截+自定义注解</li></ul><p>现在此进行一个记录，这里统一使用head添加token作为</p><h3 id="通过WebFilter进行拦截"><a href="#通过WebFilter进行拦截" class="headerlink" title="通过WebFilter进行拦截"></a>通过WebFilter进行拦截</h3><h4 id="1-添加Filter"><a href="#1-添加Filter" class="headerlink" title="1. 添加Filter"></a>1. 添加Filter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Loginservice loginservice;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LoginProperties loginProperties;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoginFilter</span><span class="hljs-params">(Loginservice loginservice, LoginProperties loginProperties)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loginservice = loginservice;<br>        <span class="hljs-built_in">this</span>.loginProperties = loginProperties;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">httpServletRequest</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;<br>        <span class="hljs-comment">// 过滤路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">requestURI</span> <span class="hljs-operator">=</span> httpServletRequest.getRequestURI();<br>        <span class="hljs-keyword">if</span> (!loginProperties.getFilterExcludeUrl().contains(requestURI)) &#123;<br>            <span class="hljs-comment">// 获取token</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> httpServletRequest.getHeader(Constant.TOKEN_HEADER_NAME);<br>            <span class="hljs-comment">// FIXME 通过redis进行token校验</span><br>            <span class="hljs-comment">// FIXME token续期逻辑</span><br>            <span class="hljs-keyword">if</span>(loginservice.checkUserToken())&#123;<br>                <br>                BaseResponse resRes=BaseResponse.error(ErrorCode.NOLOGIN);<br>                <span class="hljs-comment">//FIXME resRes 通过response返回</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        chain.doFilter(request, response);<br>    &#125;<br><br>  <br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-添加配置项"><a href="#2-添加配置项" class="headerlink" title="2.添加配置项"></a>2.添加配置项</h4><p>将拦截器配置到工程中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginProperties loginProperties;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginService loginservice;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加登录过滤器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="hljs-title function_">loginFilterRegistration</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 注册LoginFilter</span><br>        FilterRegistrationBean&lt;Filter&gt; registrationBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>&lt;&gt;();<br>        registrationBean.setFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginFilter</span>(loginservice, loginProperties));<br>        <span class="hljs-comment">// 设置名称</span><br>        registrationBean.setName(<span class="hljs-string">&quot;loginFilter&quot;</span>);<br>        <span class="hljs-comment">// 设置拦截路径</span><br>        registrationBean.addUrlPatterns(loginProperties.getFilterIncludeUrl().toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]));<br>        <span class="hljs-comment">// 指定顺序，数字越小越靠前</span><br>        registrationBean.setOrder(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> registrationBean;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="通过Interceptor进行拦截"><a href="#通过Interceptor进行拦截" class="headerlink" title="通过Interceptor进行拦截"></a>通过Interceptor进行拦截</h3><p>其原理与Filter类似，区别是Interceptor属于SpringMvc的拦截器，而Filter属于Sevlet的拦截器，实现方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterception</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginService loginservice;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(Constant.TOKEN_HEADER_NAME);<br>      loginservice.checkUserToken();<br>        <span class="hljs-comment">// 放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>同样：配置配置项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> LoginProperties loginProperties;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> LoginInterception loginInterception;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(loginInterception)<br>                .addPathPatterns(loginProperties.getInterceptorIncludeUrl())<br>                .excludePathPatterns(loginProperties.getInterceptorExcludeUrl());<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="aop-注解拦截"><a href="#aop-注解拦截" class="headerlink" title="aop + 注解拦截"></a>aop + 注解拦截</h3><p>该拦截方案思路是由于所有接口都是通过 @RestController 或 @Controller 发出的，所以通过对该注解进行切面，即可拦截所有请求，对于白名单的设置，可以设置一个注解，判断调用的接口是否添加该注解即可进行过滤，针对不需要登录的接口，只要加上注解即可。</p><h4 id="1-添加免登录注解"><a href="#1-添加免登录注解" class="headerlink" title="1.添加免登录注解"></a>1.添加免登录注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 免登录接口注解，使用方法：在需要免登录的接口添加该注解</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> LoginNoValidator &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="添加aop相关依赖"><a href="#添加aop相关依赖" class="headerlink" title="添加aop相关依赖"></a>添加aop相关依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--aop相关的依赖引入--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="添加切点、通过环绕增强进行拦截"><a href="#添加切点、通过环绕增强进行拦截" class="headerlink" title="添加切点、通过环绕增强进行拦截"></a>添加切点、通过环绕增强进行拦截</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Order(1)</span> <span class="hljs-comment">// 设置优先级最高</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginAspect</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br><br>    <span class="hljs-meta">@Value(value=&quot;$&#123;cjhx.tokenExpTime&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String tokenExpTime;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginService loginService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  切点，所有RestController类注解的方法</span><br><span class="hljs-comment">     *  拦截类或者是方法上标注注解的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pointcut(value = &quot;@within(org.springframework.web.bind.annotation.RestController)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointCut</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-meta">@Around(&quot;pointCut()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">before</span><span class="hljs-params">(ProceedingJoinPoint joinpoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <br>        <span class="hljs-comment">// 获取方法方法上的LoginValidator注解</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">methodSignature</span> <span class="hljs-operator">=</span> (MethodSignature)joinpoint.getSignature();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> methodSignature.getMethod();<br>        <span class="hljs-type">LoginNoValidator</span> <span class="hljs-variable">loginNoValidator</span> <span class="hljs-operator">=</span> method.getAnnotation(LoginNoValidator.class);<br>        <span class="hljs-comment">// 如果有，则不校验</span><br>        <span class="hljs-keyword">if</span> (loginNoValidator != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> joinpoint.proceed(joinpoint.getArgs());<br>        &#125;<br>        <br>        <span class="hljs-comment">// 正常校验 获取request和response</span><br>        <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">requestAttributes</span> <span class="hljs-operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>        <span class="hljs-keyword">if</span> (requestAttributes == <span class="hljs-literal">null</span> || requestAttributes.getResponse() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果不是从前端过来的，没有request，则直接放行</span><br>            <span class="hljs-keyword">return</span> joinpoint.proceed(joinpoint.getArgs());<br>        &#125;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> requestAttributes.getRequest();<br>        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> requestAttributes.getResponse();<br>        <span class="hljs-comment">// 获取token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(SysConstant.TOKEN_HEADER_NAME);<br>        <span class="hljs-comment">// FIXME token校验、token续期等</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回未登录的错误信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response ServletResponse</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnNoLogin</span><span class="hljs-params">(HttpServletResponse response)</span>  &#123;<br><br>        log.info(<span class="hljs-string">&quot;用户登录校验失败&quot;</span>);<br>        PrintWriter writer=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>            writer=response.getWriter();<br>            BaseResponse baseResponse= BaseResponse.fail(ErrorCode.LOGIN);<br>            writer.write(JsonUtil.obj2String(baseResponse));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(e.getMessage(),e);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            writer.close();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对不需要校验的接口添加注解"><a href="#对不需要校验的接口添加注解" class="headerlink" title="对不需要校验的接口添加注解"></a>对不需要校验的接口添加注解</h4><p>例如: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(value = &quot;员工登录接口&quot;)</span><br>    <span class="hljs-meta">@PostMapping(&quot;user/emp/login&quot;)</span><br>    <span class="hljs-meta">@LoginNoValidator</span><br>    <span class="hljs-keyword">public</span> BaseResponse <span class="hljs-title function_">employeeLogin</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> EmpLoginReq empLoginReq)</span>&#123;<br><br><br>        LoginUser user=loginService.employLoginAuth(empLoginReq);<br>        <span class="hljs-keyword">return</span> BaseResponse.ok(user);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="三种方式的优先级"><a href="#三种方式的优先级" class="headerlink" title="三种方式的优先级"></a>三种方式的优先级</h3><hr><h2 id="获取登录用户信息（当前登录用户上下文）"><a href="#获取登录用户信息（当前登录用户上下文）" class="headerlink" title="获取登录用户信息（当前登录用户上下文）"></a>获取登录用户信息（当前登录用户上下文）</h2><p>由于调用每个接口都是独立的一个线程，所以在此为了方便获取用户信息，我们考虑使用ThreadLocal的方式，利用空间换取时间。将信息保存在线程中，可以随时获取。</p><h4 id="关于ThreadLocal"><a href="#关于ThreadLocal" class="headerlink" title="关于ThreadLocal"></a>关于ThreadLocal</h4><p>先看关于这个类的API：<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html">https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html</a></p><p>它的核心思想是：共享变量在每个<strong>线程</strong>都有一个<strong>副本</strong>，每个线程操作的都是自己的副本，对另外的线程没有影响。</p><p>ThreadLocal叫做线程变量，意思是ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p><p>ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：</p><p>因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来</p><p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p><p>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。</p><p>这里推荐一遍文章：<a href="https://juejin.cn/post/7097754858593189901#heading-9%EF%BC%8C%E4%BB%8B%E7%BB%8D%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%EF%BC%8C%E6%9B%B4%E5%A4%9A%E7%9A%84%E4%B8%8D%E5%9C%A8%E8%B5%98%E8%BF%B0%E3%80%82">https://juejin.cn/post/7097754858593189901#heading-9，介绍的比较详细，更多的不在赘述。</a></p><p>这里直接使用：</p><h4 id="改造方法"><a href="#改造方法" class="headerlink" title="改造方法"></a>改造方法</h4><p>现建立一个工具类，里面是一个ThreadLocal对象，存储用户信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginUserUtil</span> &#123;<br><br>    <span class="hljs-comment">/** 线程池变量 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;LoginUser&gt; LOGIN_USER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LoginUserUtil</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LoginUser <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> LOGIN_USER.get();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(LoginUser user)</span> &#123;<br>        LOGIN_USER.set(user);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        LOGIN_USER.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后对上面的切面进行改造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;pointCut()&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">before</span><span class="hljs-params">(ProceedingJoinPoint joinpoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 获取方法方法上的LoginValidator注解</span><br>    <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">methodSignature</span> <span class="hljs-operator">=</span> (MethodSignature)joinpoint.getSignature();<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> methodSignature.getMethod();<br>    <span class="hljs-type">LoginNoValidator</span> <span class="hljs-variable">loginNoValidator</span> <span class="hljs-operator">=</span> method.getAnnotation(LoginNoValidator.class);<br>    <span class="hljs-comment">// 如果有，则不校验</span><br>    <span class="hljs-keyword">if</span> (loginNoValidator != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> joinpoint.proceed(joinpoint.getArgs());<br>    &#125;<br>    <span class="hljs-comment">// 正常校验 获取request和response</span><br>    <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">requestAttributes</span> <span class="hljs-operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>    <span class="hljs-keyword">if</span> (requestAttributes == <span class="hljs-literal">null</span> || requestAttributes.getResponse() == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果不是从前段过来的，没有request，则直接放行</span><br>        <span class="hljs-keyword">return</span> joinpoint.proceed(joinpoint.getArgs());<br>    &#125;<br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> requestAttributes.getRequest();<br>    <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> requestAttributes.getResponse();<br>    <span class="hljs-comment">// 获取token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(SysConstant.TOKEN_HEADER_NAME);<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(token)) &#123;<br>        returnNoLogin(response);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// token 校验</span><br>    <span class="hljs-comment">// 从redis中拿token对应user</span><br>    <span class="hljs-type">LoginUser</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> loginService.tokenAuth(token);<br>    Object result;<br>    <span class="hljs-keyword">try</span> &#123;<br>        LoginUserUtil.put(user);<br>        <span class="hljs-comment">// 放行</span><br>        result=joinpoint.proceed(joinpoint.getArgs());<br>    &#125;<span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// 保证ThreadLocal对象 必须删除，防止内存泄漏</span><br>        LoginUserUtil.remove();<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里注意：<strong>使用ThreadLocal一定要记得remove！！！防止内存泄漏</strong></p><h2 id="关于用户踢下线的改造方案"><a href="#关于用户踢下线的改造方案" class="headerlink" title="关于用户踢下线的改造方案"></a>关于用户踢下线的改造方案</h2><p>在原来的设计中 token使用了UUID的方式，在redis中以uuid作为key，用户信息作为value存储在redis中，这种方式有一个问题，当用户在登录后，需要强制踢下线，或者在仅允许用户在一台设备登录的情况就无法实现，这里记录一下我的改造方案，当然有更好的方案，也欢迎大家提出。</p><p>方案原理：</p><ol><li>生成token改为使用使用aes加密算法，将用户id，用户类型、登录方式等需要区分的用户信息再加上时间戳生成一个token</li><li>存入redis时，将上述的用户id、用户类型等信息组成key，存入redis中</li><li>校验时，需要先对token进行解密，获取到用户id等信息，然后在和redis中的key进行校验并拿到完整的用户上下文信息</li></ol><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> LoginUser <span class="hljs-title function_">tokenAuth</span><span class="hljs-params">(String token)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> decryptTokenKey(token);<br>        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(key))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;token不合法&quot;</span>);<br>        LoginUser user=(LoginUser)redisTemplate.opsForValue().get(key);<br>        <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(ErrorCode.LOGIN.named(),<span class="hljs-string">&quot;登录已失效，请重新登录&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(loginProperties.getSingleLogin() &amp;&amp; !StringUtils.equals(token,user.getAccessToken()))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(ErrorCode.LOGIN.named()<br>                    ,<span class="hljs-string">&quot;您的账号可能使用其他方式登录了，请重新登录，如果非您本人操作，请及时修改密码&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 续期token</span><br>        redisTemplate.expire(key,loginProperties.getTokenExpTime(),TimeUnit.MINUTES);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;login&quot;)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginProperties</span> &#123;<br>    <span class="hljs-comment">// token过期时间/分钟</span><br>    <span class="hljs-keyword">private</span> Long tokenExpTime;<br>    <span class="hljs-comment">// 秘钥key,（加密），生成方法在AesUtil中</span><br>    <span class="hljs-keyword">private</span> String aesKey;<br>    <span class="hljs-comment">// 是否开启用户单次登录</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">singleLogin</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//向工具类设置加密秘钥</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        AesUtil.setGlobalkey(aesKey);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springboot</tag>
      
      <tag>登录</tag>
      
      <tag>ThreadLocal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDE新装后常用软件及配置</title>
    <link href="/2022/05/16/IDE%E6%96%B0%E8%A3%85%E5%90%8E%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/05/16/IDE%E6%96%B0%E8%A3%85%E5%90%8E%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA-相关配置"><a href="#IDEA-相关配置" class="headerlink" title="IDEA 相关配置"></a>IDEA 相关配置</h1><p>每次新装IDEA后都需要配好多东西，在这里汇总一下，方便一次性修改</p><h2 id="插件类安装"><a href="#插件类安装" class="headerlink" title="插件类安装"></a>插件类安装</h2><p>常用插件有：</p><ul><li>Lombok lombok专用</li><li>Translation  翻译插件</li><li>MapStruct Support MapStruct支持（使用mapstruct时安装）</li><li>Save Action 自动保存配置</li><li>GitToolBox git管理增强</li><li>GsonFormatPlus json处理</li><li>MavenHelper maven依赖可视化管理，类型eclipse的maven依赖管理</li><li>String Manipulation String格式转换工具</li><li>Codota AI Autocomplete for Java and JavaScript 智能代码补全</li><li>Rainbow Brackets 彩虹括号</li><li>MybatiesX mybatisplus 工具，重点是免费</li></ul><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><h3 id="jdk默认配置"><a href="#jdk默认配置" class="headerlink" title="jdk默认配置"></a>jdk默认配置</h3><blockquote><p>File-&gt;New Projects Settings-&gt;Editor-&gt;Project Strucrure for New Projects</p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f872babc53c8451e9004710a057d1e88~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/252ef62b45d64973bb37ed30e35d2089~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="编码改为utf-8"><a href="#编码改为utf-8" class="headerlink" title="编码改为utf-8"></a>编码改为utf-8</h3><blockquote><p>File-&gt;Settings-&gt;Editor-&gt;File Encodings</p></blockquote><h3 id="maven默认配置"><a href="#maven默认配置" class="headerlink" title="maven默认配置"></a>maven默认配置</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8275046b1b04089b4f2a95583172ea0~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0beed61959954b7691ac05380586f4f3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="注释配置"><a href="#注释配置" class="headerlink" title="注释配置"></a>注释配置</h3><h4 id="类添加模板"><a href="#类添加模板" class="headerlink" title="类添加模板"></a>类添加模板</h4><p>路径：</p><blockquote><p>File–&gt;New Projects Settings–&gt;Editor–&gt;File and Code Templates</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>:$&#123;Name&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>:yadmire</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;HOUR&#125;:$&#123;MINUTE&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: $&#123;description&#125;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37fc36c0dbd440a68b0d54bb035ca1a4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="方法添加自动注释模版"><a href="#方法添加自动注释模版" class="headerlink" title="方法添加自动注释模版"></a>方法添加自动注释模版</h4><p>路径：</p><blockquote><p>File–&gt;Settings–&gt;Editor–&gt;Live Templates</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56fdd3a2dd484642ae8a168edcc69078~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48d8b32384744557a54e90cfe06f9448~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0a344f282a94eb1ad81b2688f577d45~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>常用软件</category>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>IDE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2022/05/15/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/05/15/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式–单例模式"><a href="#设计模式–单例模式" class="headerlink" title="设计模式–单例模式"></a>设计模式–单例模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>这种模式涉及到一个单一的类，该类负责<strong>创建自己的对象</strong>，同时确保<strong>只有单个对象</strong>被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><ul><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ul><p><strong>主要解决</strong>：一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用</strong>：当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决</strong>：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>关键代码</strong>：构造函数是私有的。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。<br>2、避免对资源的多重占用（比如写文件操作）。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>单例模式有懒汉式、饿汉式、双层校验锁模式，额外的：ENUM 枚举也是一种单例</p><h3 id="饿汉式（线程安全）"><a href="#饿汉式（线程安全）" class="headerlink" title="饿汉式（线程安全）"></a>饿汉式（线程安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@className</span> Singleton1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>:yadmire</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2022-05-15 16:17</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 饿汉式单例 Demo</span><br><span class="hljs-comment"> * 优点：没有加锁，执行效率会提高。</span><br><span class="hljs-comment"> * 缺点：类加载时就初始化，浪费内存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton1</span> &#123;<br>    <span class="hljs-comment">//私有化构造，不允许新建对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton1</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton1 INSTANCE=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton1</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Singleton1 <span class="hljs-title function_">getSigleton</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉式-线程不安全-有缺陷，不可取"><a href="#懒汉式-线程不安全-有缺陷，不可取" class="headerlink" title="懒汉式-线程不安全(有缺陷，不可取)"></a>懒汉式-线程不安全(有缺陷，不可取)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yadmire.design.ceational.singleton;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@className</span> Singleton2</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: yadmire</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2022-05-15 16:24</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 懒汉式 （在第一次调用的时候实例化自己）</span><br><span class="hljs-comment"> *  这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton2</span> &#123;<br>    <span class="hljs-comment">//私有化构造，不允许新建对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton2</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton2 INSTANCE;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Singleton2 <span class="hljs-title function_">getSigleton</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 首次加载时进行创建</span><br>        <span class="hljs-keyword">if</span>(INSTANCE==<span class="hljs-literal">null</span>)&#123;<br>            INSTANCE=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton2</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式-线程安全"></a>懒汉式-线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yadmire.design.ceational.singleton;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@className</span> Singleton3</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: yadmire</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2022-05-15 16:29</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 懒汉式-加锁，线程安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton3</span> &#123;<br>    <span class="hljs-comment">// 私有化构造</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton3</span> <span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton3 INSTANCE=<span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 加锁，保证单例，但是比较重，影响效率</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">synchronized</span> Singleton3 <span class="hljs-title function_">getSingleton3</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(INSTANCE==<span class="hljs-literal">null</span>)&#123;<br>            INSTANCE=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton3</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉式–双检锁"><a href="#懒汉式–双检锁" class="headerlink" title="懒汉式–双检锁"></a>懒汉式–双检锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yadmire.design.ceational.singleton;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@className</span> Singleton4</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: yadmire</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2022-05-15 16:34</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 饿汉式-双重检查机制</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton4</span> &#123;<br><br>    <span class="hljs-comment">// 这里添加 volatile 保证创建过程是线程可见的</span><br>    <span class="hljs-comment">// new 操作在字节码层面上会分解成3个操作：</span><br>    <span class="hljs-comment">// 1. 给 singleton 分配内存</span><br>    <span class="hljs-comment">// 2. 调用 Singleton 的构造函数来初始化成员变量，形成实例</span><br>    <span class="hljs-comment">// 3. 将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null了）</span><br>    <span class="hljs-comment">// 通过添加 volatile （内存屏障）保证线程的可见性与顺序性，同时保证不会发生指令重排，</span><br>    <span class="hljs-comment">// 但是此处保证的不是new 时的指令重排，而是保证在写操作时，通过内存屏障，为该内存区域加锁，保证不会有读操作，保证写期间不会有读该内存区域的操作</span><br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton4 INSTANCE= <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton4</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton4 <span class="hljs-title function_">getINSTANCE</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">// 局部加锁，增加效率</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton4.class)&#123;<br>                <span class="hljs-keyword">if</span>(INSTANCE ==<span class="hljs-literal">null</span>)&#123;<br>                    INSTANCE=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton4</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举本身也是单例的，比如，如下的验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@className</span> Singleton5</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: yadmire</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2022-05-15 16:58</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 额外：枚举类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span>  <span class="hljs-title class_">Singleton5</span> &#123;<br>    SINGLETON_5;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>验证代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSingletonEnum</span><span class="hljs-params">()</span>&#123;<br>        System.out.printf(<span class="hljs-string">&quot;test for Singleton Enum&quot;</span>);<br>        <span class="hljs-type">Singleton5</span> <span class="hljs-variable">singleton1</span> <span class="hljs-operator">=</span> Singleton5.SINGLETON_5;<span class="hljs-comment">//枚举类型实例化（静态块中）</span><br>        singleton1.setName(<span class="hljs-string">&quot;单例1&quot;</span>);<br>        System.out.println(singleton1.getName());<br><br>        <span class="hljs-type">Singleton5</span> <span class="hljs-variable">singleton2</span> <span class="hljs-operator">=</span> Singleton5.SINGLETON_5;<br>        singleton2.setName(<span class="hljs-string">&quot;单例2&quot;</span>);<br>        System.out.println(singleton2.getName());<br><br>        System.out.println(singleton1.getName() + <span class="hljs-string">&quot;:&quot;</span> + singleton2.getName());<br><br>        <span class="hljs-comment">// 断言 两者是同一个对象</span><br>        Assert.assertTrue(singleton1==singleton2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件设计基础</category>
      
      <category>设计模式</category>
      
      <category>创建型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式综述</title>
    <link href="/2022/05/13/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0/"/>
    <url>/2022/05/13/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h2><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p><h2 id="设计模式的6大原则"><a href="#设计模式的6大原则" class="headerlink" title="设计模式的6大原则"></a>设计模式的6大原则</h2><ul><li><p><strong>开闭原则（Open Close Principle）</strong></p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p></li><li><p><strong>里氏代换原则（Liskov Substitution Principle）</strong></p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p></li><li><p><strong>依赖倒转原则（Dependence Inversion Principle）</strong></p><p>针对接口编程，依赖于抽象而不依赖于具体，它是里氏代换原则的基础</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle）</strong></p><p>使用多个隔离的接口，比使用单个接口要好。降低类之间的耦合度。</p></li><li><p><strong>迪米特法则，又称最少知道原则（Demeter Principle）</strong></p><p>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p><strong>合成复用原则（Composite Reuse Principle）</strong></p><p>尽量使用合成&#x2F;聚合的方式，而不是使用继承。</p></li></ul><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>设计模式有两种分类方式：根据 <code>模式的目的</code> 和<code>模式的作用范围</code> </p><ol><li><p>根据模式的目的：</p><p><strong>创建型模式</strong>：</p><p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。</p><p><strong>结构型模式：</strong></p><p>用于描述如何将类或对象按某种布局组成更大的结构</p><p><strong>行为型模式：</strong></p><p>用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。</p></li><li><p>根据模式的作用</p><p><strong>类模式</strong> 用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF 中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</p><p><strong>对象型模式</strong> 用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。</p><p>具体如下表所示：</p></li></ol><p><img src="https://image.wyxcl.xyz/cb8065380cd79123e9200cf00d04c68ab3b7802f.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>软件设计基础</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用mapStruct 进行pojo类的转换</title>
    <link href="/2022/05/13/java/%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/%E5%88%A9%E7%94%A8mapStruct%20%E8%BF%9B%E8%A1%8Cpojo%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/05/13/java/%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/%E5%88%A9%E7%94%A8mapStruct%20%E8%BF%9B%E8%A1%8Cpojo%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="利用mapStruct-进行pojo类的转换"><a href="#利用mapStruct-进行pojo类的转换" class="headerlink" title="利用mapStruct 进行pojo类的转换"></a>利用mapStruct 进行pojo类的转换</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>MapStruct 是一个代码生成器，它极大地简化了基于约定而不是配置方法的 Java Bean 类型之间映射的实现。生成的映射代码使用普通方法调用，因此快速、类型安全且易于理解。</p><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>多层应用程序通常需要在不同的对象模型（例如实体和 DTO）之间进行映射。编写此类映射代码是一项繁琐且容易出错的任务。MapStruct旨在通过尽可能地自动化来简化这项工作。对比BeanUtils ,该框架使用get、set方式实现，相较于反射效率更高，同时，支持特殊的映射关系，比BeanUtils更加灵活。</p><p>与其他映射框架相比，MapStruct 在编译时生成 Bean 映射，从而确保高性能，允许快速的开发人员反馈和彻底的错误检查。</p><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>MapStruct是一个注释处理器，它插入到Java编译器中，可以在命令行构建（Maven，Gradle等）以及IDE中使用。</p><p>官网：<a href="https://mapstruct.org/">MapStruct – Java bean mappings, the easy way!</a></p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><h3 id="方案一-直接引入"><a href="#方案一-直接引入" class="headerlink" title="方案一 直接引入"></a>方案一 直接引入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.2.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.2.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Notice：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct-jdk8<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mapstruct.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>很多博客上写的 mapstruct-jdk8 坐标已在新版本中废弃</strong></p><hr><h3 id="方案二-通过插件引入（官网）"><a href="#方案二-通过插件引入（官网）" class="headerlink" title="方案二 通过插件引入（官网）"></a>方案二 通过插件引入（官网）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">org.mapstruct.version</span>&gt;</span>1.4.2.Final<span class="hljs-tag">&lt;/<span class="hljs-name">org.mapstruct.version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br> ...<br> <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br> ...<br> <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span> <span class="hljs-comment">&lt;!-- depending on your project --&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span> <span class="hljs-comment">&lt;!-- depending on your project --&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>                     <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span><br>                         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                     <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>                     <span class="hljs-comment">&lt;!-- other annotation processors --&gt;</span><br>                 <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>             <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="IDE配置"><a href="#IDE配置" class="headerlink" title="IDE配置"></a>IDE配置</h2><p>官网地址：<a href="https://mapstruct.org/documentation/ide-support/">IDE Support – MapStruct</a></p><p>另外 idea可以考虑安装<code>MapStructSupport</code>插件,在设置mapping的时候很好用</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14fef488ee114ee8bd60d28c19af5114~tplv-k3u1fbpfcp-watermark.image" alt="image-20220511181318198.png"></p><h2 id="使用方法及DEMO"><a href="#使用方法及DEMO" class="headerlink" title="使用方法及DEMO"></a>使用方法及DEMO</h2><h3 id="1-创建POJO"><a href="#1-创建POJO" class="headerlink" title="1.创建POJO"></a>1.创建POJO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Data</span><br> <span class="hljs-meta">@NoArgsConstructor</span><br> <span class="hljs-meta">@AllArgsConstructor</span><br> <span class="hljs-meta">@Builder</span><br> <span class="hljs-meta">@ApiModel(&quot;用户卡新增修改&quot;)</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddModifyUserCardVo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">7504607649930524455L</span>;<br> ​<br>     <span class="hljs-meta">@ApiModelProperty(value = &quot;密码&quot;, example = &quot;123456&quot;, required = true, position = -1, notes = &quot;传加密后的密文,默认MD5(加密后密文是32位)加密方式&quot;)</span><br>     <span class="hljs-keyword">private</span> String password;<br> ​<br>     <span class="hljs-meta">@ApiModelProperty(value = &quot;&quot;, example = &quot;风之诗&quot;, required = false)</span><br>     <span class="hljs-keyword">private</span> String tradeAccountName;<br> ​<br>     <span class="hljs-meta">@ApiModelProperty(value = &quot;电话号码&quot;, example = &quot;15770634444&quot;, required = false)</span><br>     <span class="hljs-keyword">private</span> String phoneNo;<br> ​<br>     <span class="hljs-meta">@ApiModelProperty(value = &quot;通讯地址&quot;, example = &quot;xx省xx市xx区xxx&quot;, required = false)</span><br>     <span class="hljs-keyword">private</span> String adddress;<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 新增卡信息</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-meta">@ApiModel(&quot;客户卡信息&quot;)</span><br> <span class="hljs-meta">@Data</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustUserParam</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br> ​<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5708253734967403586L</span>;<br>     <span class="hljs-meta">@ApiModelProperty(value = &quot;密码&quot;, example = &quot;123456&quot;, required = true, position = -1, notes = &quot;传加密后的密文&quot;)</span><br>     <span class="hljs-keyword">private</span> String password;<br> ​<br>     <span class="hljs-meta">@ApiModelProperty(value = &quot;&quot;, example = &quot;风之诗&quot;, required = false)</span><br>     <span class="hljs-keyword">private</span> String userName;<br> ​<br>     <span class="hljs-meta">@ApiModelProperty(value = &quot;电话号码&quot;, example = &quot;15770634444&quot;, required = false)</span><br>     <span class="hljs-keyword">private</span> String phoneNo;<br> ​<br>     <span class="hljs-meta">@ApiModelProperty(value = &quot;通讯地址&quot;, example = &quot;xx省xx市xx区xxx&quot;, required = false)</span><br>     <span class="hljs-keyword">private</span> String adddress;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="2-创建转换Interface"><a href="#2-创建转换Interface" class="headerlink" title="2.创建转换Interface"></a>2.创建转换Interface</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Mapper</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BankCardMapper</span> &#123;<br>     <span class="hljs-type">BankCardMapper</span> <span class="hljs-variable">INSTANCT</span> <span class="hljs-operator">=</span> Mappers.getMapper(BankCardMapper.class);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="3-将Interface注入Spring"><a href="#3-将Interface注入Spring" class="headerlink" title="3.将Interface注入Spring"></a>3.将Interface注入Spring</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> ​<br> <span class="hljs-meta">@Mapper(componentModel=&quot;spring&quot;)</span> <span class="hljs-comment">// 接口注入Spring，相当于加了一个@Component</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BankCardMapper</span> &#123;<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 接口实现类的实例</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-type">BankCardMapper</span> <span class="hljs-variable">INSTANCT</span> <span class="hljs-operator">=</span> Mappers.getMapper(BankCardMapper.class);<br>     CustBankParam <span class="hljs-title function_">addCardParamConvert</span><span class="hljs-params">(AddModifyBankCardVo addModifyBankCardVo)</span>;<br> &#125;<br></code></pre></td></tr></table></figure><blockquote><p>componentModel 有四个可选项：</p><p>default： 默认 不注入，使用 Mappers.getMapper获取实例对象</p><p>spring：（常用）实现类上添加了@Component</p><p>cdi：</p><p>jsr330：生成的实现类上会添加@javax.inject.Named 和@Singleton，可以通过 @Inject注解获取</p></blockquote><h3 id="4-添加转换接口"><a href="#4-添加转换接口" class="headerlink" title="4.添加转换接口"></a>4.添加转换接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Mapper(componentModel=&quot;spring&quot;)</span> <span class="hljs-comment">// </span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BankCardMapper</span> &#123;<br>     CustBankParam <span class="hljs-title function_">addCardParamConvert</span><span class="hljs-params">(AddModifyBankCardVo addModifyBankCardVo)</span>;<br> &#125;<br>     <br></code></pre></td></tr></table></figure><h3 id="5-在Servce层使用接口"><a href="#5-在Servce层使用接口" class="headerlink" title="5.在Servce层使用接口"></a>5.在Servce层使用接口</h3><p>注入mapper;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Autowired</span><br> <span class="hljs-keyword">private</span> BankCardMapper bankCardMapper;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dealService</span><span class="hljs-params">(AddModifyBankCardVo addModifyBankCardVo)</span>&#123;<br>      <span class="hljs-comment">// ... 业务逻辑</span><br> <span class="hljs-type">CustBankParam</span> <span class="hljs-variable">custBankParam</span> <span class="hljs-operator">=</span> bankCardMapper.addCardParamConvert(addModifyBankCardVo);<br>     <span class="hljs-comment">// ... 业务逻辑</span><br> &#125;<br></code></pre></td></tr></table></figure><h3 id="6-特殊转换"><a href="#6-特殊转换" class="headerlink" title="6. 特殊转换"></a>6. 特殊转换</h3><h4 id="6-1-使用Mapping对属性进行特殊处理"><a href="#6-1-使用Mapping对属性进行特殊处理" class="headerlink" title="6.1 使用Mapping对属性进行特殊处理"></a>6.1 使用Mapping对属性进行特殊处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mappings(&#123;</span><br><span class="hljs-meta">            @Mapping(source = &quot;tradeAccountName&quot;,target = &quot;cusName&quot;),// 不同名称之间转换</span><br><span class="hljs-meta">            @Mapping(target = &quot;password&quot;, ignore=true),//忽略密码，不进行映射</span><br><span class="hljs-meta">            @Mapping(target = &quot;createDt&quot;, expression = &quot;java(new java.util.Date())&quot;),//支持表达式 </span><br><span class="hljs-meta">            // 注意： 这个属性不能与source()、defaultValue()、defaultExpression()(可与source共同使用，当source的值为null的时候使用该表达式)、qualifiedBy()、qualifiedByName()或constant()一起使用。</span><br><span class="hljs-meta">            </span><br><span class="hljs-meta">            @Mapping(target = &quot;updateDt&quot;, dateFormat=”yyyy-MM-dd“),//时间戳转换</span><br><span class="hljs-meta">            @Mapping(target = &quot;captalMode&quot;, defaultValue=&quot;1&quot;),//设置默认值，可设置source</span><br><span class="hljs-meta">        &#125;)</span><br>CustBankParam <span class="hljs-title function_">addCardParamConvert</span><span class="hljs-params">(AddModifyBankCardVo addModifyBankCardVo)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-2-逆映射"><a href="#6-2-逆映射" class="headerlink" title="6.2 逆映射"></a>6.2 逆映射</h4><p>在双向映射的情况下，例如从实体到DTO以及从DTO到实体，前向方法和反向方法的映射规则通常是相似的，并且可以通过切换source和来简单地反转target。</p><p>使用注释 <code>@InheritInverseConfiguration</code> 表示方法应继承相应反向方法的反向配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CustBankParam <span class="hljs-title function_">addCardParamConvert</span><span class="hljs-params">(AddModifyBankCardVo addModifyBankCardVo)</span>;<br><br><span class="hljs-meta">@InheritInverseConfiguration</span><br>AddModifyBankCardVo <span class="hljs-title function_">addModifyBankCardVoConvert</span><span class="hljs-params">(CustBankParam addModifyBankCardVo)</span>;<br></code></pre></td></tr></table></figure><p>1）有一个注解@InheritConfiguration(下文提到)与该注解长得很像，请注意区分，虽然他们的功能有点相似，但是他们是不同的注解; 2）该注解虽然可以实现反转赋值，但是有一种情况需要手动加强——原映射的Mapping中没有source(典型的使用了expression、constant属性的都属于)。对于有这种情况的属性，原映射与新映射都需要指定出来；</p><p>3）该注解只有一个属性name，它的值是原映射名。你可以把它理解为原映射对应的方法的名字，即方法的名字就是映射名。如上面的例子，规则名是”addCardParamConvert”。那该注解可以这样写<code>@InheritInverseConfiguration(name=&quot;addCardParamConvert&quot;)</code>。</p><h4 id="6-3利用已有的对象映射更新对象-InheritConfiguration"><a href="#6-3利用已有的对象映射更新对象-InheritConfiguration" class="headerlink" title="6.3利用已有的对象映射更新对象 @InheritConfiguration"></a>6.3利用已有的对象映射更新对象 <code>@InheritConfiguration</code></h4><p>使用方法与6.2类似，但功能上有些有差异，上面已经介绍，这里注意区分即可。</p><h4 id="6-4（补充）公共属性的映射"><a href="#6-4（补充）公共属性的映射" class="headerlink" title="6.4（补充）公共属性的映射"></a>6.4（补充）公共属性的映射</h4><p>对于我们平时新增、修改等操作，需要对修改create_time、update_time 等字段，有人说在修改数据库的时候使用mybatis-plus的自动填充即可，这也是个比较好的方案。可惜的是该框架不在我们公司的技术选型范围内，所以打算在类的转换上想办法了，如果在mapstruct上配置，这些字段需要对每个接口都配置一次，这显得很麻烦。能不能配置一个公共的方法就显得很重要。于是翻阅文档，发现了一个比较好玩的实验性功能：<br><a href="https://mapstruct.org/documentation/stable/reference/html/#mapping-composition">https://mapstruct.org/documentation/stable/reference/html/#mapping-composition</a></p><p><img src="http://image.wyxcl.xyz/typore/image-20220525102839916-16534457460791.png" alt="image-20220525102839916">上代码DEMO：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 新增时使用注解，入参需要添加 LoginUser loginUser</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-meta">@Mappings(&#123;</span><br><span class="hljs-meta">        @Mapping(target = &quot;createdTime&quot;,expression = &quot;java(new java.sql.Timestamp(System.currentTimeMillis()))&quot;),</span><br><span class="hljs-meta">        @Mapping(target = &quot;updatedTime&quot;,expression = &quot;java(new java.sql.Timestamp(System.currentTimeMillis()))&quot;),</span><br><span class="hljs-meta">        @Mapping(target = &quot;createdBy&quot;,source = &quot;loginUser.unionUserId&quot;),</span><br><span class="hljs-meta">        @Mapping(target = &quot;updatedBy&quot;,source = &quot;loginUser.unionUserId&quot;),</span><br><span class="hljs-meta">        @Mapping(target = &quot;tenantId&quot;,source = &quot;loginUser.tenantId&quot;),</span><br><span class="hljs-meta">        @Mapping(target = &quot;revision&quot;,expression = &quot;java(new Integer(1))&quot;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> InsertMapper &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Mapper(componentModel = <span class="hljs-string">&quot;spring&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EduActivityMapper</span> &#123;<br><br><br>    <span class="hljs-meta">@InsertMapper</span><br>    EduActivity <span class="hljs-title function_">insertEduActivity</span><span class="hljs-params">(EduActivityReq eduActivityReq, LoginUser loginUser)</span>;<br></code></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>mapstruct的使用比起传统的BeanUtils更加灵活效率更高，但是每次转换都要新增一个接口，这是一个缺点吧，后续在使用中有什么心得，还会继续补充<br>不过最重要的还是要经常翻阅一下API吧</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>pojo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
